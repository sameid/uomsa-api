var qs = require('querystring'),
    request = require('request'),
    crypto = require('crypto'),
    url = require('url'),
    waitress = require('waitress'),
    util = require('util'),
    config;

// define constants
var PLACES_RANKBY_DEFAULT = 'prominence';
var PLACES_RANKBY_DISTANCE = 'distance';

// this is deprecated
exports.setProxy = function(uri) {
  config('proxy', uri);
***REMOVED***;

var _config = {
  'google-client-id': null,
  'stagger-time': 200,
  'encode-polylines': true,
  'secure': false,
  'proxy': null,
  set 'google-private-key'(privateKey) {
    if (privateKey){
      // Google private keys are URL friendly base64, needs to be replaced with base64 valid characters
      this.googlePrivateKey = privateKey.replace(/-/g,'+').replace(/_/g,'/');
      this.googlePrivateKey = new Buffer(this.googlePrivateKey, 'base64');
    ***REMOVED*** else {
      this.googlePrivateKey = null;
    ***REMOVED***
  ***REMOVED***,
  get 'google-private-key'() {
    return this.googlePrivateKey || null;
  ***REMOVED***
***REMOVED***;


exports.config = config = function(key, value) {
  if (arguments.length === 1) {
    if (typeof key === 'object' && key !== null) {
      var settings = key;
      for (var key in settings) {
        config(key, settings[key]);
      ***REMOVED***
    ***REMOVED*** else {
      return _config[key];
    ***REMOVED***
  ***REMOVED*** else {
    _config[key] = value;
  ***REMOVED***
***REMOVED***;

// http://code.google.com/apis/maps/documentation/places/
exports.places = function(latlng, radius, key, callback, sensor, types, lang, name, rankby, pagetoken) {

  var args = {
    location: latlng,
    key: key
  ***REMOVED***;

  rankby = rankby || PLACES_RANKBY_DEFAULT;
  if (rankby !== PLACES_RANKBY_DEFAULT && rankby !== PLACES_RANKBY_DISTANCE) {
    rankby = PLACES_RANKBY_DEFAULT;
  ***REMOVED***
  args.rankby = rankby;

  // radius can be passed in the request only if the rankby parameter is not 'distance'
  // Ranking results by distance will set a fixed search radius of 50km
  if (typeof radius !== "undefined" && radius !== null && rankby !== PLACES_RANKBY_DISTANCE) {
    args.radius = radius;
  ***REMOVED***

  if (typeof types !== "undefined" && types !== null) {
    args.types = types;
  ***REMOVED***

  if (typeof lang !== "undefined" && lang !== null) {
    args.lang = lang;
  ***REMOVED***

  if (typeof name !== "undefined" && name !== null) {
    args.name = name;
  ***REMOVED***

  if (typeof pagetoken !== "undefined" && pagetoken !== null) {
    args.pagetoken = pagetoken;
  ***REMOVED***

  args.sensor = sensor || 'false';

  return makeRequest('/maps/api/place/search/json', args, true, returnObjectFromJSON(callback));
***REMOVED***;

exports.placeDetails = function(referenceId, key, callback, sensor, lang) {
  var args = {
    reference: referenceId,
    key: key
  ***REMOVED***;
  if (lang) args.lang = lang;
  args.sensor = sensor || 'false';

  var path = '/maps/api/place/details/json';
  return makeRequest(path, args, true, returnObjectFromJSON(callback));
***REMOVED***;

// http://code.google.com/apis/maps/documentation/geocoding/
exports.geocode = function(address, callback, sensor, bounds, region, language) {
  var args = {
    'address': address
  ***REMOVED***;
  if (bounds) args.bounds = bounds;
  if (region) args.region = region;
  if (language) args.language = language;
  args.sensor = sensor || 'false';

  var path = '/maps/api/geocode/json';

  return makeRequest(path, args, config('secure'), returnObjectFromJSON(callback));
***REMOVED***;

// http://code.google.com/apis/maps/documentation/geocoding/#ReverseGeocoding
exports.reverseGeocode = function(latlng, callback, sensor, language ) {
  var args = {
    'latlng': latlng
  ***REMOVED***;
  if (language) args.language = language;
  args.sensor = sensor || 'false';

  var path = '/maps/api/geocode/json';

  return makeRequest(path, args, config('secure'), returnObjectFromJSON(callback));
***REMOVED***;

// http://code.google.com/apis/maps/documentation/distancematrix/
exports.distance = function(origins, destinations, callback, sensor, mode, alternatives, avoid, units, language) {
  var args = {
    'origins': origins,
    'destinations': destinations
  ***REMOVED***;
  if (mode) args.mode = mode.toLowerCase();
  if (avoid) args.avoid = avoid;
  if (units) args.units = units;
  if (language) args.language = language;
  args.sensor = sensor || 'false';

  var path = '/maps/api/distancematrix/json';
  return makeRequest(path, args, config('secure'), returnObjectFromJSON(callback));
***REMOVED***;

// http://code.google.com/apis/maps/documentation/directions/
// departureTime and arrivalTime must be passed as UNIX timestamp => Math.floor((new Date()).getTime()/1000)
exports.directions = function(origin, destination, callback, sensor, mode, waypoints, alternatives, avoid, units, language, departureTime, arrivalTime, region) {

  var args = {
    'origin': origin,
    'destination': destination
  ***REMOVED***;

  if (mode) args.mode = mode.toLowerCase();

  // for mode transit you MUST pass either departur or arrival time
  if (mode === 'transit' && ((typeof departureTime === "undefined" || departureTime === null) && (typeof arrivalTime === "undefined" || arrivalTime === null))) {
    var error = new Error('If you set the mode to "transit" you must also specify either a departure_time or an arrival_time');
    if (typeof callback === 'function') {
      return callback(error);
    ***REMOVED***
    else {
      throw error;
    ***REMOVED***
  ***REMOVED***

  if (typeof departureTime !== "undefined" && departureTime !== null) {
    if (mode === 'transit' || mode === 'driving') {

      args.departure_time = departureTime

      if (typeof arrivalTime !== "undefined" && arrivalTime !== null) {
        args.arrival_time = arrivalTime
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (waypoints) args.waypoints = waypoints;
  if (alternatives) args.alternatives = alternatives;
  if (avoid) args.avoid = avoid;
  if (units) args.units = units;
  if (language) args.language = language;
  if (region) args.region = region;
  args.sensor = sensor || 'false';

  var path = '/maps/api/directions/json';

  return makeRequest(path, args, config('secure'), returnObjectFromJSON(callback));
***REMOVED***;

// http://code.google.com/apis/maps/documentation/elevation/
// http://code.google.com/apis/maps/documentation/elevation/#Locations
exports.elevationFromLocations = function(locations, callback, sensor) {
  if (config('encode-polylines')){
    locations = 'enc:' + createEncodedPolyline(locations);
  ***REMOVED***
  var args = {
    'locations': locations
  ***REMOVED***;
  args.sensor = sensor || 'false';

  var path = '/maps/api/elevation/json';

  return makeRequest(path, args, config('secure'), returnObjectFromJSON(callback));
***REMOVED***;

// http://code.google.com/apis/maps/documentation/elevation/#Paths
exports.elevationFromPath = function(path, samples, callback, sensor) {
  if (config('encode-polylines')){
    path = 'enc:' + createEncodedPolyline(path);
  ***REMOVED***
  var args = {
    'path': path,
    'samples': samples
  ***REMOVED***;
  args.sensor = sensor || 'false';
  var reqPath = '/maps/api/elevation/json';

  var maxlen = 1500;
  var count = (path.length < maxlen ? 1 : Math.ceil(path.length/maxlen));

  if (count === 1) {
    makeRequest(reqPath, args, config('secure'), returnObjectFromJSON(callback));
  ***REMOVED*** else {
    var done = waitress(count, function(err, results) {
      results = results.sort(function(a, b) {
        return a.n - b.n;
      ***REMOVED***).map(function(v) {
        return v.results;
      ***REMOVED***);
      var status = "OK";
      var aggregated = [];
      results.forEach(function(result) {
        aggregated = aggregated.concat(result.results);
        if (result.status !== "OK") {
          status = result.status;
        ***REMOVED***
      ***REMOVED***);
      results = {
        results: aggregated,
        status: status
      ***REMOVED***;
      callback(null, results);
    ***REMOVED***);

    path = path.split("|");
    var pieceSize = Math.ceil(path.length / count);
    var n = 0;
    while (path.length) {
      var smallerPath = path.splice(0, pieceSize);
      // google will throttle us if we launch all the
      // requests together, so we have to stagger them.
      (function(n, path, samples) {
        path = path.join("|");
        var cb = function(err, results) {
          if (err) return done(err);
          done(null, { n: n, results: results ***REMOVED***);
        ***REMOVED***;
        setTimeout(function() {
          exports.elevationFromPath(path, samples, cb, sensor);
        ***REMOVED***, Math.floor(Math.random() * config('stagger-time')));
      ***REMOVED***)(++n, smallerPath, smallerPath.length);
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

// http://code.google.com/apis/maps/documentation/staticmaps
exports.staticMap = function(center, zoom, size, callback, sensor, maptype, markers, styles, paths) {
  var args = {
    'center': center,
    'zoom': zoom,
    'size': size
  ***REMOVED***;
  var i, k;

  if (maptype) args.maptype = maptype;
  if (markers) {
    args.markers = [];
    for (i = 0; i < markers.length; i++) {
      var marker = '';
      if (markers[i].size)     marker += '|size:'   + markers[i].size;
      if (markers[i].color)    marker += '|color:'  + markers[i].color;
      if (markers[i].label)    marker += '|label:'  + markers[i].label;
      if (markers[i].icon)     marker += '|icon:'   + markers[i].icon;
      if (markers[i].shadow)   marker += '|shadow:' + markers[i].shadow;
      if (markers[i].location) marker += '|'      + markers[i].location;
      args.markers[i] = marker;
    ***REMOVED***
  ***REMOVED***
  if (styles) {
    args.style = [];
    for (i = 0; i < styles.length; i++) {
      var new_style = '';
      if (styles[i].feature) new_style += '|feature:' + styles[i].feature;
      if (styles[i].element) new_style += '|element:' + styles[i].element;

      var rules = styles[i].rules;

      if (rules) {
        for (k in rules) {
          var rule = rules[k];
          new_style += '|' + k + ':' + rule;
        ***REMOVED***
      ***REMOVED***
      args.style[i] = new_style;
    ***REMOVED***
  ***REMOVED***
  if (paths) {
    args.path = [];
    for (i = 0; i < paths.length; i++) {
      var new_path = '';
      if (paths[i].weight)    new_path += '|weight:' + paths[i].weight;
      if (paths[i].color)     new_path += '|color:' + paths[i].color;
      if (paths[i].fillcolor) new_path += '|fillcolor:' + paths[i].fillcolor;

      var points = paths[i].points;

      if (points) {
        if (config('encode-polylines')){
          new_path += '|enc:' + createEncodedPolyline(points);
        ***REMOVED*** else {
          for (k = 0; k < points.length; k++) {
            new_path += '|' + points[k];
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      args.path[i] = new_path.replace(/^\|/, '');
    ***REMOVED***
  ***REMOVED***
  args.sensor = sensor || 'false';

  var path = '/maps/api/staticmap';

  return makeRequest(path, args, config('secure'), callback, 'binary');
***REMOVED***;

// http://code.google.com/apis/maps/documentation/streetview
exports.streetView = function(size, location, callback, sensor, heading, fov, pitch) {
  var args = {
    'size': size,
    'location': location
  ***REMOVED***;
  if (heading) {
    heading = parseInt(heading, 10);
    if (heading >= 0 && heading <= 360) {
      args.heading = heading;
    ***REMOVED***
  ***REMOVED***
  if (fov) {
    fov = parseInt(fov, 10);
    if (fov >= 0 && fov <= 120) {
      args.fov = fov;
    ***REMOVED***
  ***REMOVED***
  if (pitch) {
    pitch = parseInt(pitch, 10);
    if (pitch >= -90 && pitch <= 90) {
      args.pitch = pitch;
    ***REMOVED***
  ***REMOVED***

  args.sensor = sensor || 'false';
  var path = '/maps/api/streetview';

  return makeRequest(path, args, config('secure'), callback, 'binary');
***REMOVED***;

//  Helper function to check and convert an array of points, be it strings/numbers/etc
//    into the format used by Google Maps for representing lists of latitude/longitude pairs
exports.checkAndConvertArrayOfPoints = function(input) {
  switch (typeof input) {
    case 'object':
      if (input instanceof Array) {
        var output = [];
        for (var i = 0; i < input.length; i++) {
          output.push(exports.checkAndConvertPoint(input[i]));
        ***REMOVED***
        return output.join('|');
      ***REMOVED***
      break;
    case 'string':
      return input;
  ***REMOVED***
  throw(new Error("Unrecognized input: checkAndConvertArrayOfPoints accepts Arrays and Strings"));
***REMOVED***;

//  Helper function to check and convert an points, be it strings/arrays of numbers/etc
//    into the format used by Google Maps for representing latitude/longitude pairs
exports.checkAndConvertPoint = function(input) {
  switch (typeof input) {
    case 'object':
      if (input instanceof Array) {
        return input[0].toString() + ',' + input[1].toString();
      ***REMOVED***
      break;
    case 'string':
      return input;
  ***REMOVED***
  throw(new Error("Unrecognized input: checkAndConvertPoint accepts Arrays of Numbers and Strings"));
***REMOVED***;

//  Wraps the callback function to convert the output to a javascript object
var returnObjectFromJSON = function(callback) {
  if (typeof callback === 'function') {
    return function(err, jsonString) {

      if (err){
        callback(err);
        return;
      ***REMOVED***

      try {
        callback(err, JSON.parse(jsonString));
      ***REMOVED*** catch (e) {
        callback(e);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
  return false;
***REMOVED***;

// Algorithm pull from Google's definition of an encoded polyline
//
// https://developers.google.com/maps/documentation/utilities/polylinealgorithm

function createEncodedPolyline(points) {
  // Dear maintainer:
  //
  // Once you are done trying to 'optimize' this routine,
  // and have realized what a terrible mistake that was,
  // please increment the following counter as a warning
  // to the next guy:
  //
  // total_hours_wasted_here = 11
  //
  var i, dlat, dlng;
  var plat = 0;
  var plng = 0;
  var encoded_points = "";
  if(typeof points === 'string'){
    points = points.split('|');
  ***REMOVED***

  for(i = 0; i < points.length; i++) {
    var point = points[i].split(',');
    var lat = point[0];
    var lng = point[1];
    var late5 = Math.round(lat * 1e5);
    var lnge5 = Math.round(lng * 1e5);
    dlat = late5 - plat;
    dlng = lnge5 - plng;
    plat = late5;
    plng = lnge5;
    encoded_points += encodeSignedNumber(dlat) + encodeSignedNumber(dlng);
  ***REMOVED***
  return encoded_points;
***REMOVED***

exports.createEncodedPolyline = createEncodedPolyline;


function encodeNumber(num) {
  var encodeString = "";
  var nextValue, finalValue;
  while (num >= 0x20) {
    nextValue = (0x20 | (num & 0x1f)) + 63;
    encodeString += (String.fromCharCode(nextValue));
    num >>= 5;
  ***REMOVED***
  finalValue = num + 63;
  encodeString += (String.fromCharCode(finalValue));
  return encodeString;
***REMOVED***

function encodeSignedNumber(num) {
  var sgn_num = num << 1;
  if (num < 0) {
    sgn_num = ~(sgn_num);
  ***REMOVED***
  return(encodeNumber(sgn_num));
***REMOVED***

function buildUrl(path, args) {
  if (config('google-client-id') && config('google-private-key')) {
    args.client = config('google-client-id');

    var query = qs.stringify(args).split('');
    for (var i = 0; i < query.length; ++i) {
      // request will escape these which breaks the signature
      if (query[i] === "'") query[i] = escape(query[i]);
    ***REMOVED***
    query = query.join('');

    path = path + "?" + query;

    // Create signer object passing in the key, telling it the key is in base64 format
    var signer = crypto.createHmac('sha1', config('google-private-key'));

    // Get the signature, telling it to return the sig in base64 format
    var signature = signer.update(path).digest('base64');
    signature = signature.replace(/\+/g,'-').replace(/\//g,'_');
    path += "&signature=" + signature;
    return path;
  ***REMOVED*** else {
    return path + "?" + qs.stringify(args);
  ***REMOVED***
***REMOVED***

// Makes the request to Google Maps API.
// If secure is true, uses https. Otherwise http is used.
var makeRequest = function(path, args, secure, callback, encoding) {
  var maxlen = 2048;
  var consoleKey = config('console-key');

  if (consoleKey){
    // google requires https when including an apiKey
    secure = true;
    args.key = consoleKey;
  ***REMOVED***

  path = buildUrl(path, args);

  if (path.length > maxlen) {
    error = new Error("Request too long for google to handle (" + maxlen + " characters).");
    if (typeof callback === 'function') {
      return callback(error);
    ***REMOVED***
    throw error;
  ***REMOVED***

  var options = {
    uri: (secure ? 'https' : 'http') + '://maps.googleapis.com' + path
  ***REMOVED***;

  if (encoding) options.encoding = encoding;
  if (config('proxy')) options.proxy = config('proxy');

  if (typeof callback === 'function') {
    request(options, function (error, res, data) {
      if (error) {
        return callback(error);
      ***REMOVED***
      if (res.statusCode === 200) {
        return callback(null, data);
      ***REMOVED***
      error = new Error(data);
      error.code = res.statusCode;
      return callback(error, data);
    ***REMOVED***);
  ***REMOVED***

  return options.uri;
***REMOVED***;

// vim: set expandtab sw=2:

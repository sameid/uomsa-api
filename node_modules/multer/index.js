var os = require('os');
var fs = require('fs');
var path = require('path');
var crypto = require('crypto');
var Busboy = require('busboy');
var mkdirp = require('mkdirp');
var qs = require('qs');

module.exports = function(options) {

  options = options || {***REMOVED***;
  options.includeEmptyFields = options.includeEmptyFields || false;

  // specify the destination directory, else, the uploads will be moved to the temporary dir of the system
  var dest;

  if (options.dest) {
    dest = options.dest;
  ***REMOVED*** else {
    dest = os.tmpdir();
  ***REMOVED***

  // make sure the dest dir exists
  mkdirp(dest, function(err) { if (err) throw err; ***REMOVED***);

  // renaming function for the uploaded file - need not worry about the extension
  // ! if you want to keep the original filename, write a renamer function which does that
  var rename = options.rename || function(fieldname, filename) {
    var random_string = fieldname + filename + Date.now() + Math.random();
    return crypto.createHash('md5').update(random_string).digest('hex');
  ***REMOVED***;

  return function(req, res, next) {

    var readFinished = false;
    var fileCount = 0;

    req.body = req.body || {***REMOVED***;
    req.files = req.files || {***REMOVED***;

    if (req.headers['content-type'] &&
        req.headers['content-type'].indexOf('multipart/form-data') === 0 &&
        (req.method === 'POST' || req.method === 'PUT')
    ) {

      if (options.onParseStart) { options.onParseStart(); ***REMOVED***

      // add the request headers to the options
      options.headers = req.headers;

      var busboy = new Busboy(options);

      // handle text field data
      busboy.on('field', function(fieldname, val, valTruncated, keyTruncated) {

        // if includeEmptyFields is false and there is no value then don't
        // attach the fields to req.body
        if (!options.includeEmptyFields && !val) return;

        if (req.body.hasOwnProperty(fieldname) && val) {
          if (Array.isArray(req.body[fieldname])) {
            req.body[fieldname].push(val);
          ***REMOVED*** else {
            req.body[fieldname] = [req.body[fieldname], val];
          ***REMOVED***
        ***REMOVED*** else {
          req.body[fieldname] = val;
        ***REMOVED***

      ***REMOVED***);

      // handle files
      busboy.on('file', function(fieldname, fileStream, filename, encoding, mimetype) {

        var ext, newFilename, newFilePath;

        // don't attach to the files object, if there is no file
        if (!filename) return fileStream.resume();

        // defines is processing a new file
        fileCount++;

        if (filename.indexOf('.') > 0) { ext = '.' + filename.split('.').slice(-1)[0]; ***REMOVED***
        else { ext = ''; ***REMOVED***

        newFilename = rename(fieldname, filename.replace(ext, '')) + ext;
        newFilePath = path.join(dest, newFilename);

        var file = {
          fieldname: fieldname,
          originalname: filename,
          name: newFilename,
          encoding: encoding,
          mimetype: mimetype,
          path: newFilePath,
          extension: (ext === null) ? null : ext.replace('.', ''),
          size: 0,
          truncated: null
        ***REMOVED***;

        // trigger "file upload start" event
        if (options.onFileUploadStart) {
          var proceed = options.onFileUploadStart(file);
          // if the onFileUploadStart handler returned null, it means we should proceed further, discard the file!
          if (proceed == false) {
            fileCount--;
            return fileStream.resume();
          ***REMOVED***
        ***REMOVED***

        var ws = fs.createWriteStream(newFilePath);
        fileStream.pipe(ws);

        fileStream.on('data', function(data) {
          if (data) { file.size += data.length; ***REMOVED***
          // trigger "file data" event
          if (options.onFileUploadData) { options.onFileUploadData(file, data); ***REMOVED***
        ***REMOVED***);

        ws.on('finish', function() {
          file.truncated = fileStream.truncated;
          if (!req.files[fieldname]) { req.files[fieldname] = []; ***REMOVED***
          req.files[fieldname].push(file);
          // trigger "file end" event
          if (options.onFileUploadComplete) { options.onFileUploadComplete(file); ***REMOVED***

          // defines has completed processing one more file
          fileCount--;
          onFinish();
        ***REMOVED***);

        fileStream.on('error', function(error) {
          // trigger "file error" event
          if (options.onError) { options.onError(error, next); ***REMOVED***
          else next(error);
        ***REMOVED***);

        fileStream.on('limit', function () {
          if (options.onFileSizeLimit) { options.onFileSizeLimit(file); ***REMOVED***
        ***REMOVED***);

        ws.on('error', function(error) {
          // trigger "file error" event
          if (options.onError) { options.onError(error, next); ***REMOVED***
          else next(error);
        ***REMOVED***);

      ***REMOVED***);

      busboy.on('partsLimit', function() {
        if (options.onPartsLimit) { options.onPartsLimit(); ***REMOVED***
      ***REMOVED***);

      busboy.on('filesLimit', function() {
        if (options.onFilesLimit) { options.onFilesLimit(); ***REMOVED***
      ***REMOVED***);

      busboy.on('fieldsLimit', function() {
        if (options.onFieldsLimit) { options.onFieldsLimit(); ***REMOVED***
      ***REMOVED***);

      busboy.on('finish', function() {
        readFinished = true;
        onFinish();
      ***REMOVED***);

      /**
       * Pass the control to the next middleware in stack
       * only if the read and write stream are finished
       */
      var onFinish = function () {
        if (!readFinished || fileCount > 0) return;

        for (var field in req.files) {
          if (req.files[field].length === 1) {
            req.files[field] = req.files[field][0];
          ***REMOVED***
        ***REMOVED***

        // Parse the body and create a best structure
        req.body = qs.parse(req.body);

        // when done parsing the form, pass the control to the next middleware in stack
        if (options.onParseEnd) { options.onParseEnd(req, next); ***REMOVED***
        else { next(); ***REMOVED***
      ***REMOVED***;

      req.pipe(busboy);

    ***REMOVED***

    else { return next(); ***REMOVED***

  ***REMOVED***

***REMOVED***
